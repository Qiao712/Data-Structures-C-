# GreedyAlgorithm
分阶段的进行，在每个阶段做当前已知最好的工作，而不考虑下一步的操作，产生局部最优解。

## 例
* Dijkstra
* Prim
* Kruskal
* 调度问题（先处理占用时间小的，使得平均等待时间最小）
* Huffman编码
* 装箱问题

### Huffman编码
用于文件压缩(file compression)
#### 前缀码 Character code
将字符等信息放在**叶结点**上，形参一颗**满树**。
从根节点出发，用1指示向左，用0指示向右，到达叶节点时得到的序列即为叶结点上这个信息（字符）的编码。
#### 哈夫曼算法 Huffman's Algorithm
如何构造一个总价值最小（使信息占用二进制位最小）的编码树->哈夫曼编码(Huffman Code)
* 核心思想：让出现频率高的字符在树中的深度更低（编码其所用的bit更少）
* 初始时，所有出现的字符各自构成各成**单节点的树**。一棵树的权值为它的树叶的频率的和
* 每次任意选取最小权值的两棵树T1和T2，并以任意形式合并这两棵树
* 最后得到最优的哈夫曼编码树

### 装箱问题
#### 联机的(on-line)
* (M表示最优解)
* 下项适合(next fit)算法: 仅检查是否能装进刚刚装进物品的箱子中，无法装入则开辟下一个箱子 （所用箱子数不超过2M）
* 首次适合(first fit)算法: 扫描所有箱子，将物品放入第一个能容下它的箱子（可优化到O(N logN)）(所用箱子不超过⌈17M/10⌉)
* 最佳适合(best fit)算法: 将物品放入能容纳它的最满的箱子（不会超过17M/10左右）
#### 脱机的(off-line)
* 将物品降序排列，再应用**首次适合算法**或**最佳适合算法**->即**首次适合递减算法**和**最佳适合递减算法**
* 首次递减适合算法不超过(4M+1)/3